/*
 * Apache License
 * Version 2.0, January 2004
 * http://www.apache.org/licenses/
 *
 * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 * 1. Definitions.
 *
 * "License" shall mean the terms and conditions for use, reproduction, and
 * distribution as defined by Sections 1 through 9 of this document.
 *
 * "Licensor" shall mean the copyright owner or entity authorized by the copyright
 * owner that is granting the License.
 *
 * "Legal Entity" shall mean the union of the acting entity and all other entities
 * that control, are controlled by, or are under common control with that entity.
 * For the purposes of this definition, "control" means (i) the power, direct or
 * indirect, to cause the direction or management of such entity, whether by
 * contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the
 * outstanding shares, or (iii) beneficial ownership of such entity.
 *
 * "You" (or "Your") shall mean an individual or Legal Entity exercising
 * permissions granted by this License.
 *
 * "Source" form shall mean the preferred form for making modifications, including
 * but not limited to software source code, documentation source, and configuration
 * files.
 *
 * "Object" form shall mean any form resulting from mechanical transformation or
 * translation of a Source form, including but not limited to compiled object code,
 * generated documentation, and conversions to other media types.
 *
 * "Work" shall mean the work of authorship, whether in Source or Object form, made
 * available under the License, as indicated by a copyright notice that is included
 * in or attached to the work (an example is provided in the Appendix below).
 *
 * "Derivative Works" shall mean any work, whether in Source or Object form, that
 * is based on (or derived from) the Work and for which the editorial revisions,
 * annotations, elaborations, or other modifications represent, as a whole, an
 * original work of authorship. For the purposes of this License, Derivative Works
 * shall not include works that remain separable from, or merely link (or bind by
 * name) to the interfaces of, the Work and Derivative Works thereof.
 *
 * "Contribution" shall mean any work of authorship, including the original version
 * of the Work and any modifications or additions to that Work or Derivative Works
 * thereof, that is intentionally submitted to Licensor for inclusion in the Work
 * by the copyright owner or by an individual or Legal Entity authorized to submit
 * on behalf of the copyright owner. For the purposes of this definition,
 * "submitted" means any form of electronic, verbal, or written communication sent
 * to the Licensor or its representatives, including but not limited to
 * communication on electronic mailing lists, source code control systems, and
 * issue tracking systems that are managed by, or on behalf of, the Licensor for
 * the purpose of discussing and improving the Work, but excluding communication
 * that is conspicuously marked or otherwise designated in writing by the copyright
 * owner as "Not a Contribution."
 *
 * "Contributor" shall mean Licensor and any individual or Legal Entity on behalf
 * of whom a Contribution has been received by Licensor and subsequently
 * incorporated within the Work.
 *
 * 2. Grant of Copyright License.
 *
 * Subject to the terms and conditions of this License, each Contributor hereby
 * grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
 * irrevocable copyright license to reproduce, prepare Derivative Works of,
 * publicly display, publicly perform, sublicense, and distribute the Work and such
 * Derivative Works in Source or Object form.
 *
 * 3. Grant of Patent License.
 *
 * Subject to the terms and conditions of this License, each Contributor hereby
 * grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
 * irrevocable (except as stated in this section) patent license to make, have
 * made, use, offer to sell, sell, import, and otherwise transfer the Work, where
 * such license applies only to those patent claims licensable by such Contributor
 * that are necessarily infringed by their Contribution(s) alone or by combination
 * of their Contribution(s) with the Work to which such Contribution(s) was
 * submitted. If You institute patent litigation against any entity (including a
 * cross-claim or counterclaim in a lawsuit) alleging that the Work or a
 * Contribution incorporated within the Work constitutes direct or contributory
 * patent infringement, then any patent licenses granted to You under this License
 * for that Work shall terminate as of the date such litigation is filed.
 *
 * 4. Redistribution.
 *
 * You may reproduce and distribute copies of the Work or Derivative Works thereof
 * in any medium, with or without modifications, and in Source or Object form,
 * provided that You meet the following conditions:
 *
 * You must give any other recipients of the Work or Derivative Works a copy of
 * this License; and
 * You must cause any modified files to carry prominent notices stating that You
 * changed the files; and
 * You must retain, in the Source form of any Derivative Works that You distribute,
 * all copyright, patent, trademark, and attribution notices from the Source form
 * of the Work, excluding those notices that do not pertain to any part of the
 * Derivative Works; and
 * If the Work includes a "NOTICE" text file as part of its distribution, then any
 * Derivative Works that You distribute must include a readable copy of the
 * attribution notices contained within such NOTICE file, excluding those notices
 * that do not pertain to any part of the Derivative Works, in at least one of the
 * following places: within a NOTICE text file distributed as part of the
 * Derivative Works; within the Source form or documentation, if provided along
 * with the Derivative Works; or, within a display generated by the Derivative
 * Works, if and wherever such third-party notices normally appear. The contents of
 * the NOTICE file are for informational purposes only and do not modify the
 * License. You may add Your own attribution notices within Derivative Works that
 * You distribute, alongside or as an addendum to the NOTICE text from the Work,
 * provided that such additional attribution notices cannot be construed as
 * modifying the License.
 * You may add Your own copyright statement to Your modifications and may provide
 * additional or different license terms and conditions for use, reproduction, or
 * distribution of Your modifications, or for any such Derivative Works as a whole,
 * provided Your use, reproduction, and distribution of the Work otherwise complies
 * with the conditions stated in this License.
 *
 * 5. Submission of Contributions.
 *
 * Unless You explicitly state otherwise, any Contribution intentionally submitted
 * for inclusion in the Work by You to the Licensor shall be under the terms and
 * conditions of this License, without any additional terms or conditions.
 * Notwithstanding the above, nothing herein shall supersede or modify the terms of
 * any separate license agreement you may have executed with Licensor regarding
 * such Contributions.
 *
 * 6. Trademarks.
 *
 * This License does not grant permission to use the trade names, trademarks,
 * service marks, or product names of the Licensor, except as required for
 * reasonable and customary use in describing the origin of the Work and
 * reproducing the content of the NOTICE file.
 *
 * 7. Disclaimer of Warranty.
 *
 * Unless required by applicable law or agreed to in writing, Licensor provides the
 * Work (and each Contributor provides its Contributions) on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
 * including, without limitation, any warranties or conditions of TITLE,
 * NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are
 * solely responsible for determining the appropriateness of using or
 * redistributing the Work and assume any risks associated with Your exercise of
 * permissions under this License.
 *
 * 8. Limitation of Liability.
 *
 * In no event and under no legal theory, whether in tort (including negligence),
 * contract, or otherwise, unless required by applicable law (such as deliberate
 * and grossly negligent acts) or agreed to in writing, shall any Contributor be
 * liable to You for damages, including any direct, indirect, special, incidental,
 * or consequential damages of any character arising as a result of this License or
 * out of the use or inability to use the Work (including but not limited to
 * damages for loss of goodwill, work stoppage, computer failure or malfunction, or
 * any and all other commercial damages or losses), even if such Contributor has
 * been advised of the possibility of such damages.
 *
 * 9. Accepting Warranty or Additional Liability.
 *
 * While redistributing the Work or Derivative Works thereof, You may choose to
 * offer, and charge a fee for, acceptance of support, warranty, indemnity, or
 * other liability obligations and/or rights consistent with this License. However,
 * in accepting such obligations, You may act only on Your own behalf and on Your
 * sole responsibility, not on behalf of any other Contributor, and only if You
 * agree to indemnify, defend, and hold each Contributor harmless for any liability
 * incurred by, or claims asserted against, such Contributor by reason of your
 * accepting any such warranty or additional liability.
 *
 * END OF TERMS AND CONDITIONS
 *
 * APPENDIX: How to apply the Apache License to your work
 *
 * To apply the Apache License to your work, attach the following boilerplate
 * notice, with the fields enclosed by brackets "[]" replaced with your own
 * identifying information. (Don't include the brackets!) The text should be
 * enclosed in the appropriate comment syntax for the file format. We also
 * recommend that a file or class name and description of purpose be included on
 * the same "printed page" as the copyright notice for easier identification within
 * third-party archives.
 *
 *    Copyright 2013 Aurelian Tutuianu
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package rapaio.tutorial.pages;

import rapaio.core.RandomSource;
import rapaio.data.*;
import rapaio.distributions.empirical.KernelDensityEstimator;
import rapaio.explore.Summary;

import static rapaio.explore.Workspace.*;
import rapaio.graphics.Histogram;
import rapaio.graphics.Plot;
import rapaio.graphics.plot.ABLine;
import rapaio.graphics.plot.FunctionLine;
import rapaio.graphics.plot.Lines;
import rapaio.graphics.plot.Points;
import rapaio.sample.DiscreteSamplingWOR;
import rapaio.sample.DiscreteSamplingWR;
import rapaio.sample.DiscreteWeightedSamplingWOR;
import rapaio.sample.DiscreteWeightedSamplingWR;

import java.io.IOException;

/**
 * User: <a href="mailto:padreati@yahoo.com">Aurelian Tutuianu</a>
 */
public class DiscreteSampling implements TutorialPage {
    @Override
    public String getPageName() {
        return "DiscreteSampling";
    }

    @Override
    public String getPageTitle() {
        return "Discrete Sampling Tutorial";
    }

    @Override
    public void render() throws IOException {

        heading(1, "Discrete Sampling with Rapaio");

        p("In statistics, sampling is the process which selects a subset of observations " +
                "from within a statistical population. There are many types of sampling " +
                "methods which can be employed in statistics, like simple random sampling, " +
                "stratified sampling, systematic sampling and so on. ");
        p("However the purpose of this tutorial is to present four algorithms which " +
                "are used as building blocks by various statistical sampling methods. " +
                "The purpose of this tutorial is to present discrete random sampling methods.");

        p("<b>Definition:</b>");
        p("<i>A statistical distribution whose values can take only discrete values is " +
                "called a discrete distribution. </i>");

        p("A discrete probability distribution function is completely described by " +
                "the set of possible values the random variable can take and " +
                "by the probabilities assigned to each value.");

        p("An example of discrete distribution is the process of throwing a standard dice. " +
                "We have a finite set of outcomes of the process (6 possible values) and " +
                "a probability function value associated with each output (for a fair dice we " +
                "can associate probability \\( p(x_i) = \\frac{1}{6} \\)).");

        p("Drawing a sample from a distribution is the process of selecting some values " +
                "from the possible values \\( x_i,i=1..n \\) according with their probabilities. " +
                "Sampling is useful for far many purposes that I can describe here. " +
                "Among some very important scenarios are the simulation and the fapt that " +
                "working with a smaller sample than the given population is faster " +
                "and provides enough information for analysis. For the latter " +
                "example we can note that working with the heights and " +
                "weights of the all the people from the world (assuming that this " +
                "information is possible to collect, there are probably over 7 billions " +
                "records) is much harder than working with a sample much smaller. ");

        heading(2, "Uniform random sample with replacement");

        p("An uniform random sample is a sample from a discrete population with " +
                "an uniform distribution. A discrete uniform distribution is a distribution " +
                "which assigns equal probability mass function values to each outcome. " +
                "The previous example of throwing a fair dice is an example of uniform " +
                "distribution, since it assigns equal value \\(\\frac{1}{6}\\) to each " +
                "possible outcome \\( x_i \\). ");

        p("A sample with replacement is a sample where values of the sample can appear multiple " +
                "times. The expression \"with replacement\" can be misleading. The intuition " +
                "behind seems to follow from the following description of the process:");

        p("<i>We have a set of possible elements \\(x_i\\), each with assigned equal probability " +
                "of \\(p(x_i) \\). Take randomly one element from the set, according with " +
                "their probabilities (denote the taken element with \\(x_k\\)). " +
                "Replace the element taken from the set with a new element, which has " +
                "the same value as the element previously removed. At this stage we have again " +
                "a situation identical with the initial situation. Repeat the process of " +
                "taking elements from the original set, followed by replacing that element " +
                "with another similar element unit you collect the desired number of elements " +
                "for the sample." +
                "</i>");

        p("Of course, we don't have to replace effectively the element. Repeating " +
                "the process of throwing a fair dice multiple times is a sampling with " +
                "replacement (we don't remove and replace something during process). ");

        p("The algorithm for taking a discrete uniform sample with replacement is " +
                "fairly simple since it is based on a basic operation provided by " +
                "Java language (<code>java.util.Random.nextInt(int n);</code>)");

        code("        int[] sample = new DiscreteSamplingWR(6).sample(1000);\n" +
                "        Vector vector = new NumericVector(\"fair-dice\", sample);\n" +
                "        draw(new Histogram(vector, 6, false), 500, 200);\n");

        int[] sample = new DiscreteSamplingWR(6).sample(1000);
        Vector vector = new NumericVector("fair-dice", sample);
        draw(new Histogram(vector, 6, false), 500, 200);

        p("In the presented histogram we see frequencies obtained be taking a sample " +
                "of size 1000 of the fair-dice process outcomes. We note that the " +
                "proportions are somehow equal, which is according with our assumption " +
                "that each element have equal probability. However the values from sample " +
                "looks random:");

        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < 100; i++) {
            sb.append(sample[i]).append(", ");
            if ((i + 1) % 30 == 0) sb.append("\n");
        }
        sb.append("...");
        code(sb.toString());

        heading(2, "Uniform random sample without replacement");

        p("Sampling without replacement implies that during the process of selection " +
                "of elements which will be collected in teh desired sample, the " +
                "chosen elements are not available again for further selection. " +
                "A process like this appears when are drawn numbers for lottery. " +
                "The already selected numbers are not available for selection again. " +
                "Another expression which, at least for me, seems much clearer " +
                "is \"without repetition\". So, with replacement means a sample " +
                "with repetition, and without replacement is a sample without " +
                "repetition. ");

        p("Let's suppose that we have a lottery 6/49. At each draw 6 unique numbers in " +
                "range 1-69 are drawn. We take 100 draws and simulate:");

        code("        final int TRIALS = 100;\n" +
                "        final int SAMPLE_SIZE = 6;\n" +
                "        final int POPULATION_SIZE = 49;\n" +
                "        Vector[] vectors = new Vector[2];\n" +
                "        vectors[0] = new NumericVector(\"lottery trial\", SAMPLE_SIZE * TRIALS);\n" +
                "        vectors[1] = new NumericVector(\"winning number\", SAMPLE_SIZE * TRIALS);\n" +
                "\n" +
                "        for (int i = 0; i < TRIALS; i++) {\n" +
                "            int[] numbers = new DiscreteSamplingWOR(POPULATION_SIZE).sample(SAMPLE_SIZE);\n" +
                "            for (int j = 0; j < numbers.length; j++) {\n" +
                "                vectors[0].setValue(i * SAMPLE_SIZE + j, i);\n" +
                "                vectors[1].setValue(i * SAMPLE_SIZE + j, numbers[j] + 1);\n" +
                "            }\n" +
                "        }\n" +
                "\n" +
                "        final Frame df = new SolidFrame(\"lottery\", SAMPLE_SIZE * TRIALS, vectors);\n" +
                "        draw(new Plot() {{\n" +
                "            add(new Points(this, df.getCol(0), df.getCol(1)));\n" +
                "            opt().setPchIndex(new OneIndexVector(1));\n" +
                "            opt().setColorIndex(new OneIndexVector(34));\n" +
                "        }}, 600, 300);\n");

        final int TRIALS = 100;
        final int SAMPLE_SIZE = 6;
        final int POPULATION_SIZE = 49;
        Vector[] vectors = new Vector[2];
        vectors[0] = new NumericVector("lottery trial", SAMPLE_SIZE * TRIALS);
        vectors[1] = new NumericVector("winning number", SAMPLE_SIZE * TRIALS);

        for (int i = 0; i < TRIALS; i++) {
            int[] numbers = new DiscreteSamplingWOR(POPULATION_SIZE).sample(SAMPLE_SIZE);
            for (int j = 0; j < numbers.length; j++) {
                vectors[0].setValue(i * SAMPLE_SIZE + j, i + 1);
                vectors[1].setValue(i * SAMPLE_SIZE + j, numbers[j] + 1);
            }
        }

        final Frame df = new SolidFrame("lottery", SAMPLE_SIZE * TRIALS, vectors);
        draw(new Plot() {{
            new Points(this, df.getCol(0), df.getCol(1));
            opt().setPchIndex(1);
            opt().setColorIndex(34);
            opt().setSizeIndex(2);
        }}, 600, 300);

        p("There is random in that plot. Everywhere. A summary on the data, however, " +
                "can give us enough clues to understand that the distribution " +
                "of those numbers are still symmetric and somehow uniform.");

        Summary.summary(df);

        heading(2, "Weighted random sample with replacement");

        p("A weighted sample is a discrete random sample which does not have an " +
                "uniform distribution. A well-know example used in almost " +
                "all introductory probability classes is the biased coin. A biased coin " +
                "is a coin which is not fair. That mean the probability after a draw " +
                "to see HEAD is different than the probability to see a TAIL. ");

        p("Let's suppose we have a biased coin with \\( p(coin=HEAD) = 0.6\\) and " +
                "\\( p(coin=TAIL)=0.4\\). We simulate this experiment and we draw " +
                "the coins a lot of times. The law of large numbers tells us " +
                "that after a reasonable amount of repetitions the plugged in estimator " +
                "will tend to go the the population parameter estimated. ");

        p("During the experiment we will throw the coin 300 times and we " +
                "will plot the plugin estimate which is the number of times HEAD is " +
                "drawn divided by the number of experiments. ");

        code("        RandomSource.setSeed(1);\n" +
                "        final Vector index = new IndexVector(\"experiment no.\", 1, 1000, 1);\n" +
                "        final Vector value = new NumericVector(\"HEAD/TOTAL\", 1000);\n" +
                "        double count = 0;\n" +
                "        double total = 0;\n" +
                "        for (int i = 0; i < 300; i++) {\n" +
                "            int[] samples = new DiscreteWeightedSamplingWR(new double[]{0.6, 0.4}).sample(1);\n" +
                "            if (samples[0] == 0) count++;\n" +
                "            total++;\n" +
                "            value.setValue(i, count / total);\n" +
                "        }\n" +
                "        draw(new Plot() {{\n" +
                "            add(new ABLine(this, 0.6, true));\n" +
                "            add(new Lines(this, index, value) {{\n" +
                "                opt().setColorIndex(new OneIndexVector(2));\n" +
                "                opt().setLwd(1.5f);\n" +
                "            }});\n" +
                "            opt().setYRange(0, 1);\n" +
                "        }});\n");

        RandomSource.setSeed(1);
        final Vector index = new IndexVector("experiment no.", 1, 1000, 1);
        final Vector value = new NumericVector("HEAD/TOTAL", 1000);
        double count = 0;
        double total = 0;
        for (int i = 0; i < 300; i++) {
            int[] samples = new DiscreteWeightedSamplingWR(new double[]{0.6, 0.4}).sample(1);
            if (samples[0] == 0) count++;
            total++;
            value.setValue(i, count / total);
        }
        draw(new Plot() {{
            new ABLine(this, 0.6, true);
            new Lines(this, index, value) {{
                opt().setColorIndex(2);
                opt().setLwd(1.5f);
            }};
            opt().setYRange(0, 1);
        }});

        p("From the previous function line we see that the plugged in estimate " +
                "of the probability of HEAD has a large variation at the beginning " +
                "of our experiment. However, as number of trials increases we have " +
                "clear reasoning to confirm that the coin is biased, since " +
                "the variation decrease, the estimator converge to value 0.6 which " +
                "is not what we could expect from a fair coin. ");

        p("The sampling algorithm implemented is one of the family of alias method, " +
                "specifically is called Vose algorithm and is one of the linear " +
                "algorithms used today for discrete weighted random sampling. See more " +
                "about this algorithm here: <a href=\"http://en.wikipedia.org/wiki/Alias_method\">" +
                "http://en.wikipedia.org/wiki/Alias_method</a>.");


        heading(2, "Weighted random sample without replacement");

        p("This is the last type of discrete random sampling covered here. What we are " +
                "interested in is to generate samples without replacement (no repetition), " +
                "from a discrete distribution different than uniform distribution. ");

        p("We consider again the lottery experiment. However we want to simulate " +
                "a situation when some winning numbers are preferred over the others. " +
                "Let's suppose that our lottery favors big numbers, >= that 40. " +
                "And some other numbers, ones in interval 8-12 have " +
                "smaller probability than usual. We repeat the experiment with a " +
                "weighted sampling technique.");

        code("        vectors[0] = new NumericVector(\"loaded lottery\", SAMPLE_SIZE * TRIALS);\n" +
                "        vectors[1] = new NumericVector(\"winning number\", SAMPLE_SIZE * TRIALS);\n" +
                "\n" +
                "        double[] prob = new double[49];\n" +
                "        for (int i = 0; i <prob.length; i++) {\n" +
                "            if(i-1>=8 && i-1<=12) {\n" +
                "                prob[i]=3;\n" +
                "                continue;\n" +
                "            }\n" +
                "            if(i-1>=40) {\n" +
                "                prob[i]=30;\n" +
                "                continue;\n" +
                "            }\n" +
                "            prob[i]=10;\n" +
                "        }\n" +
                "        for (int i = 0; i < TRIALS; i++) {\n" +
                "            int[] numbers = new DiscreteWeightedSamplingWOR(prob).sample(SAMPLE_SIZE);\n" +
                "            for (int j = 0; j < numbers.length; j++) {\n" +
                "                vectors[0].setValue(i * SAMPLE_SIZE + j, i + 1);\n" +
                "                vectors[1].setValue(i * SAMPLE_SIZE + j, numbers[j] + 1);\n" +
                "            }\n" +
                "        }\n" +
                "\n" +
                "        final Frame df2 = new SolidFrame(\"lottery\", SAMPLE_SIZE * TRIALS, vectors);\n" +
                "        draw(new Plot() {{\n" +
                "            add(new Points(this, df2.getCol(0), df2.getCol(1)));\n" +
                "            opt().setPchIndex(new OneIndexVector(1));\n" +
                "            opt().setColorIndex(new OneIndexVector(34));\n" +
                "            opt().setSizeIndex(new OneNumericVector(2));\n" +
                "        }}, 600, 300);\n");

        vectors[0] = new NumericVector("loaded lottery", SAMPLE_SIZE * TRIALS);
        vectors[1] = new NumericVector("winning number", SAMPLE_SIZE * TRIALS);

        double[] prob = new double[49];
        for (int i = 0; i < prob.length; i++) {
            if (i - 1 >= 8 && i - 1 <= 12) {
                prob[i] = 3;
                continue;
            }
            if (i - 1 >= 40) {
                prob[i] = 30;
                continue;
            }
            prob[i] = 10;
        }
        for (int i = 0; i < TRIALS; i++) {
            int[] numbers = new DiscreteWeightedSamplingWOR(prob).sample(SAMPLE_SIZE);
            for (int j = 0; j < numbers.length; j++) {
                vectors[0].setValue(i * SAMPLE_SIZE + j, i + 1);
                vectors[1].setValue(i * SAMPLE_SIZE + j, numbers[j] + 1);
            }
        }

        final Frame df2 = new SolidFrame("lottery", SAMPLE_SIZE * TRIALS, vectors);
        draw(new Plot() {{
            new Points(this, df2.getCol(0), df2.getCol(1));
            opt().setPchIndex(new OneIndexVector(1));
            opt().setColorIndex(new OneIndexVector(34));
            opt().setSizeIndex(new OneNumericVector(2));
        }}, 600, 300);

        p("This time we see more than random there. There is a clear more dense " +
                "region in the upper side of the graph. Also, we can note, perhaps " +
                "not as very clear, a stripe with low density somewhere under y=13. ");

        p("To clarify a kernel density plot which approximates the population " +
                "density would help more.");

        draw(new Plot() {{
            new FunctionLine(this, new KernelDensityEstimator(df2.getCol("winning number"), 3).getPdfFunction());
            opt().setXRange(-10, 60);
            opt().setYRange(0, .05);
            opt().setColorIndex(new OneIndexVector(1));
            setBottomLabel("winning numbers");
            setLeftLabel("kernel probability density");
        }}, 600, 300);

        p("Rapaio implementation of this last algorithm is based on a wonderful algorithm " +
                "invented by Efraimidis-Spirakis. " +
                "<a href=\"http://link.springer.com/content/pdf/10.1007/978-0-387-30162-4_478.pdf\">" +
                "http://link.springer.com/content/pdf/10.1007/978-0-387-30162-4_478.pdf</a>. ");
        p("Note: the sole purpose of this tutorial is to show what and how it can " +
                "be done with Rapaio toolbox library. ");

        p(" >>>This tutorial is generated with Rapaio document printer facilities.<<< ");
    }

}
